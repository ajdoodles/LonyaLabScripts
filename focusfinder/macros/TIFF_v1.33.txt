var	filenameIndex = 1;


macro "The Incredible Focus Finder [F1]" {
	
	// When you measure it measures what you select
	// This sets it to measure what you don't need
	// decimal 3 is digits
	// integrated is the thing you're telling it to measure (integerated density, gives you int density and raw int density)
	// ^ measure of the intensity of the values in the selected value
	// redirect
	run("Set Measurements...", "integrated redirect=None decimal=3");

	dir1 = getDirectory("Choose Source Directory ");
	dir2 = getDirectory("Choose Destination Directory ");
	dir = dir2
	triple_coloc = false;

	File.makeDirectory(dir2 +"First Foci");
	File.makeDirectory(dir2 +"Second Foci"); 
	File.makeDirectory(dir2 +"Coloc");
	File.makeDirectory(dir2 +"Image");
	File.makeDirectory(dir2 +"Nuclei");
	File.makeDirectory(dir2 +"Third Foci");
	dirlist = getFileList(dir2);
	
	Telosave = dir2 + dirlist[1];
	BP1save = dir2 + dirlist[4];
	Colocsave = dir2 + dirlist[0];
	Imagesave = dir2 + dirlist[2];
	Nucleisave = dir2 + dirlist[3];
	Thirdsave = dir2 + dirlist[5];

	channel_number = getNumber("How Many Channels?", 3);
	if (channel_number == 4){
		rows = 1;
  		columns = 4;
  		rc = rows*columns;
  		labels = newArray("Channel 1", "Channel 2", "Channel 3", "Channel 4");
  		defaults = newArray(rc);
  		Dialog.create("Please Select Which Channels To Colocalize");
  		Dialog.addCheckboxGroup(rows,columns,labels,defaults);
  		Dialog.show();
       	channels = newArray();
		C_1 = Dialog.getCheckbox();
		C_2 = Dialog.getCheckbox();
		C_3 = Dialog.getCheckbox();
		C_4 = Dialog.getCheckbox();

		if (channel_number == 4 && ((C_2 == 1 && C_3 == 1 && C_4 == 1) || (C_1 == 1 && C_3 == 1 && C_4 == 1) || (C_1 == 1 && C_2 == 1 && C_3 == 1))){
			triple_coloc = true;
		} else {
			triple_coloc = false;
		}
	}


	first_autocontrastfull = getBoolean("Would you like use auto-contrasting on the first foci?");
	if (first_autocontrastfull == 0)   {

		first_autocontrastmin = getNumber("Enter Min Value", 0);
		first_autocontrastmax = getNumber("Enter Max Value", 255);

	}


if (channel_number != 2){
second_autocontrastfull = getBoolean("Would you like use auto-contrasting on the second foci?");
if (second_autocontrastfull == 0)   {

second_autocontrastmin = getNumber("Enter Min Value", 0);
second_autocontrastmax = getNumber("Enter Max Value", 255);

}}

if (channel_number == 4 && triple_coloc == 1){
third_autocontrastfull = getBoolean("Would you like use auto-contrasting on the third foci?");
if (third_autocontrastfull == 0)   {

third_autocontrastmin = getNumber("Enter Min Value", 0);
third_autocontrastmax = getNumber("Enter Max Value", 255);

}}

first_thresh = getNumber("Threshold value for first foci",-180);

if (channel_number != 2){
second_thresh = getNumber("Threshold value for second foci",-180);
}

if (channel_number == 4 && triple_coloc == 1){
third_thresh = getNumber("Threshold value for third foci",-180);
}


dapi_order = getNumber("Which channel is DAPI?", 1);

	// 
	setBatchMode(true);
	list = getFileList(dir1);
  	for (n=0; n<list.length; n++) {
  		showProgress(n+1, list.length);
		
		// Run JAVA's garbage collector
		run("Collect Garbage");


		open(dir1+list[n]);


		imagedir = File.directory;
		imagename = File.name;

		if (channel_number == 4) {
			run("Stack to Hyperstack...", "order=xyczt(default) channels=4 slices=1 frames=1 display=Color");
			if (dapi_order == 1)
				run("Duplicate...", "title=dapi duplicate channels=1");
			else if (dapi_order == 2)
	 			run("Duplicate...", "title=dapi duplicate channels=2");
	 		else if (dapi_order == 3)
				run("Duplicate...", "title=dapi duplicate channels=3");
			else if (dapi_order == 4) 
				run("Duplicate...", "title=dapi duplicate channels=4");


		if (triple_coloc == 1){
			if (C_1 == 1 && C_2 == 1 && C_3 == 1){
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=2");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_3 == 1 && C_4 == 1){	
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			
			}
			if (C_1 == 1 && C_3 == 1 && C_4 == 1){	
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
		}			
		if (triple_coloc == 0){			
			if (C_1 == 1 && C_2 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=2");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
				}
			if (C_1 == 1 && C_3 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_1 == 1 && C_4 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_3 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_4 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_3 == 1 && C_4 == 1) {
				selectWindow(imagename);
				run("Duplicate...", "title=firstfocichannel duplicate channels=3");
				selectWindow(imagename);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}	
		}	
		
	close(imagename);
	close("firstfocichannel");
	close("secondfocichannel");
	close("dapi");
	selectWindow("Composite");
	rename(imagename);
	}

	if (channel_number == 3 || channel_number == 4){
		run("Stack to Hyperstack...", "order=xyczt(default) channels=3 slices=1 frames=1 display=Color");
	}

	if (channel_number == 3){

		if (dapi_order == 1)
			run("Arrange Channels...", "new=231");
		else if (dapi_order == 2)
	 		run("Arrange Channels...", "new=132");
	 	else if (dapi_order == 3)
			run("Arrange Channels...", "new=123");
	}

if (channel_number == 2){
	run("Stack to Hyperstack...", "order=xyczt(default) channels=2 slices=1 frames=1 display=Color");
	if (dapi_order == 1)
	run("Arrange Channels...", "new=21");
	else if (dapi_order == 2)
	 run("Arrange Channels...", "new=12");
}	 

// Basically by this point we want one hyperstack for this file, with dapi channel last, and any colloc channels after
// order for the other other channels should be preserved.

// Note that i nthe triple colloc case, the 4th channel (last non-dapi) is removed and re-added later

		// Actual pipeline start

		// Mpodifying to image to be 32 -bit
		run("32-bit");


		// same as channel == 2 except do same for other channel
		if (channel_number != 2){
			run("Duplicate...", "title=dapi duplicate channels=3");
			selectWindow(imagename);
			run("Duplicate...", "title=bp1 duplicate channels=2");
			selectWindow(imagename);
			run("Duplicate...", "title=telo duplicate channels=1");
			run("Duplicate...", "title=telo1");
			run("Median...", "radius=10");
			imageCalculator("Subtract create", "telo","telo1");
			selectWindow("bp1");
			run("Duplicate...", "title=bp2");
			run("Median...", "radius=10");
			imageCalculator("Subtract create", "bp1","bp2");
			run("Merge Channels...", "c1=[Result of telo] c2=[Result of bp1] c3=[dapi] create");
			close("telo");
			close("telo1");
			close("bp1");
			close("bp2");
			close(imagename);
			selectWindow("Composite");
		run("Stack to Hyperstack...", "order=xyczt(default) channels=3 slices=1 frames=1 display=Color");
}	


	if (channel_number == 2){
		run("Duplicate...", "title=dapi duplicate channels=2");
		selectWindow(imagename);
		run("Duplicate...", "title=telo duplicate channels=1");
		run("Duplicate...", "title=telo1");
		// running median on telo1
		// specify radius, scan across image in that radius, applies value to pixles
		run("Median...", "radius=10");

		// clean up bg artifacts
		imageCalculator("Subtract create", "telo","telo1");

		// merging image calc out with dapi, dapi is still last
		run("Merge Channels...", "c1=[Result of telo] c2=[dapi] create");
		close("telo");
		close("telo1");
		selectWindow(imagename);
		selectWindow("Composite");

		// get bac kto hyper stack
		run("Stack to Hyperstack...", "order=xyczt(default) channels=2 slices=1 frames=1 display=Color");
		selectWindow("Composite");
	}

// We can skip this
run("Duplicate...", "title=Green duplicate channels=1");
//run("Grays");
run("Subtract Background...", "rolling=14");
selectWindow("Composite");

//

	if (channel_number != 2){
		run("Duplicate...", "title=Red duplicate channels=2");
		//run("Grays");
		run("Subtract Background...", "rolling=14");
		selectWindow("Composite");
		run("Duplicate...", "title=Blue duplicate channels=3");
}

else {
	run("Duplicate...", "title=Blue duplicate channels=2");
}


// dapi is selected here =
//run("Grays");
run("Subtract Background...", "rolling=300");
run("Smooth");
run("Gaussian Blur...", "sigma=3");
// make everything either black or white based on thresh
setAutoThreshold("Huang dark");
//run("Threshold...");
// ? maybe invert imaged 
// find nuclei which will either be all black or all white
setOption("BlackBackground", false);
run("Convert to Mask");
selectWindow("Composite");
close();

if (channel_number != 2){

   selectWindow("Red");
   run("8-bit");
   run("Despeckle");

   // this block should be athe autocontrast command, but it's bugged
   // so do this instead
   // counting all pixels 
   // make hist, put pixles in bins
   // find low point and high point
   // setting all values to be high point and low point
   // apply second foci to second channel (red)

   //autocontrast
   if (second_autocontrastfull == 1) {
      AUTO_THRESHOLD = 5000;
      getRawStatistics(pixcount);
      limit = pixcount/10;
      threshold = pixcount/AUTO_THRESHOLD;
      nBins = 256;
      getHistogram(values, histA, nBins);
      i = -1;
      found = false;
      do {
      	 counts = histA[++i];
      	 if (counts > limit) counts = 0;
      	 found = counts > threshold;
      } while ((!found) && (i < histA.length-1))
      hmin = values[i];
      i = histA.length;
      do {
      	 counts = histA[--i];
      	 if (counts > limit) counts = 0;
      	 found = counts > threshold;
      } while ((!found) && (i > 0))
      hmax = values[i];
      setMinAndMax(hmin, hmax);
      //print(hmin, hmax);
      run("Apply LUT");
   } else {
     setMinAndMax(second_autocontrastmin, second_autocontrastmax);
     run("Apply LUT");
   }

   run("Auto Local Threshold", "method=Mean radius=500 parameter_1=second_thresh parameter_2=0 white"); //Thresholding for second
   run("Convert to Mask");
   run("Make Binary");
}


selectWindow("Green");
run("8-bit");
run("Despeckle");

// apply second foci to second channel (green)

if (first_autocontrastfull == 1) {


//autocontrast
AUTO_THRESHOLD = 5000; 
 getRawStatistics(pixcount); 
 limit = pixcount/10; 
 threshold = pixcount/AUTO_THRESHOLD; 
 nBins = 256; 
 getHistogram(values, histA, nBins); 
 i = -1; 
 found = false; 
 do { 
         counts = histA[++i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i < histA.length-1)) 
 hmin = values[i]; 
 i = histA.length; 
 do { 

         counts = histA[--i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i > 0)) 
 hmax = values[i]; 
 setMinAndMax(hmin, hmax); 
 //print(hmin, hmax); 
run("Apply LUT");
} else {
		setMinAndMax(first_autocontrastmin, first_autocontrastmax);
		run("Apply LUT"); 
	}

 
run("Auto Local Threshold", "method=Mean radius=500 parameter_1=first_thresh parameter_2=0 white"); //Thresholding for first one
run("Convert to Mask");
run("Make Binary"); 

//The above block find the foci using local thresholding, and basically does a threshold in a radius of 500 pixels. The method of thresholding is using the mean formula. In short, every pixel in a radius of 500 is averaged, and then pixels above that average
//are assigned a value of 255 and below that value are assigned a value of 0. parameter 1 is a constant that is subtracted from the mean, so you can tweak it. There is no parameter 2, which is why it is 0. 
//Convert to Mask is the save step of the thresholding, and make binary is probably redundant, but I keep it just in case.

if (channel_number != 2) {
   run("Merge Channels...", "red=Red green=Green blue=*None* gray=*None* create");
   selectWindow("Composite");
   run("Stack to RGB");
   run("Split Channels");
   selectWindow("Composite (RGB) (blue)");
   close();
} else {
  run("Merge Channels...", "red=Green green=Green blue=*None* gray=*None* create");
  selectWindow("Composite");
  run("Stack to RGB");
  run("Split Channels");
  selectWindow("Composite (RGB) (blue)");
  close();
  selectWindow("Composite (RGB) (red)");
  close();
}

// replace this with variable later, this is only here to select the correct window

//We merge the red and green channels that we processed with thresholding. Then we split it again and discard the blue channel that is made as a result of the merge and split (since it is blank anyway). The real purpose of this operation is to get consistent image names.
//This is somewhat redundant we can make proper image names otherwise, but whatever. We can deal with this at your leisure.
//If we had two channels, we do the same as in first block but we close the blue AND red channel since they are blank. Remember, we only had the green when we do two channel counting

if (channel_number != 2){
   run("Colocalization ", "channel_1=[Composite (RGB) (red)] channel_2=[Composite (RGB) (green)] ratio=30 threshold_channel_1=15 threshold_channel_2=15 display=255  colocalizated");
}

// These inputs are just the "renamed" marges from earlier, the ones that we only needed 

//This is the colocalization plugin that we may want to reverse engineer. Basically you pick two images (which we do here), specificy some parameters for how it selects the foci (ratio is the ratio of overlap to count as a colocalization
//the other values are minumum amount of each channel in the colocalization spot I believe. It might be worthwile to have a way for advanced users to change these values. Then just tell it to go. What it does is find where things overlap. 
//It outputs a few things, it spits out a two channel image with three colors (I think, I haven't looked in a while) where the overlapping points have a value.

// If triple colloc then go bcak and add in third channel
if (channel_number == 4 && triple_coloc == 1){
		
			selectWindow("Colocalizated points (RGB) ");
			run("Make Binary");
			rename("Colocalizated points Part 1");
			open(imagedir + imagename);
			
			
					if ((C_2 == 1 && C_3 == 1 && C_4 == 1) | (C_1 == 1 && C_3 == 1 && C_4 == 1)){
					selectWindow(imagename);
					run("Duplicate...", "title=thirdfocichannel duplicate range=4");
					close(imagename);	
					}
					
					if ((C_1 == 1 && C_2 == 1 && C_3 == 1)){
					selectWindow(imagename);
					run("Duplicate...", "title=thirdfocichannel duplicate range=3");
					close(imagename);	
					}
				
			selectWindow("thirdfocichannel");
			run("Duplicate...", "title=third_med");
			run("Median...", "radius=10");
			imageCalculator("Subtract create", "thirdfocichannel","third_med");
			close("thirdfocichannel");
			close("third_med");
			selectWindow("Result of thirdfocichannel");
			rename("third_proc");
			run("32-bit");
			run("Grays");
			run("Subtract Background...", "rolling=14");
			selectWindow("third_proc");		
			run("8-bit");
			run("Despeckle");
			
			if (third_autocontrastfull == 1){
			
			
				//autocontrast
				AUTO_THRESHOLD = 5000; 
				 getRawStatistics(pixcount); 
				 limit = pixcount/10; 
				 threshold = pixcount/AUTO_THRESHOLD; 
				 nBins = 256; 
				 getHistogram(values, histA, nBins); 
				 i = -1; 
				 found = false; 
				 do { 
				         counts = histA[++i]; 
				         if (counts > limit) counts = 0; 
				         found = counts > threshold; 
				 } while ((!found) && (i < histA.length-1)) 
				 hmin = values[i]; 
				 i = histA.length; 
				 do { 
				
				         counts = histA[--i]; 
				         if (counts > limit) counts = 0; 
				         found = counts > threshold; 
				 } while ((!found) && (i > 0)) 
				 hmax = values[i]; 
				 setMinAndMax(hmin, hmax); 
				 //print(hmin, hmax); 
				run("Apply LUT"); 
						} else{
							setMinAndMax(third_autocontrastmin, third_autocontrastmax);
							run("Apply LUT"); 
						}
			   
				
			
			run("Auto Local Threshold", "method=Mean radius=500 parameter_1=third_thresh parameter_2=0 white"); //Thresholding for third one
			run("Convert to Mask");
			run("Make Binary"); 

			run("Colocalization ", "channel_1=[Colocalizated points Part 1] channel_2=[third_proc] ratio=30 threshold_channel_1=15 threshold_channel_2=15 display=255  colocalizated");



			
			}

//The above block is for the three way colocalization. Basically we convert the output of the first colocalization run into a binary image where only the regions of overlap have a value. We then reopen the original image we were supplied at the very very beginning
// but this time we keep the channel we threw away. We then process it as before and then do the colocalization again, except this time on the third channel image we processed and the product of the first colocalization.

selectWindow("Blue");
run("Convert to Mask");
run("Make Binary");
run("Adjustable Watershed", "tolerance=4");
run("Analyze Particles...", "size=1000-infinity pixel circularity=0.00-1.00 show=[Bare Outlines] display add");

//Here we work with the blue channel. The mask and binary is probably redundant as it should have been done in the previous step, but I haven't every tested removing those lines here. The watershed function is a way to split objects that 
// SHOULD be seperate, but are actually stuck together. Imagine two oranges on the table; now lay them in such a manner that they touch. You know there are two oranges, but if you were to outline them with a pencil, you would have one object.
// This is a mathematical way to determine where objects should be split. The tolerance is a parameter used in the equation. Basically it models water flowing from the ends, and if water touches water before it touches the other end, there should be a break.
// The analyze particles is the function that selects the objects you have found. Basically at this point we have a bunch of round (or nearly round) blobs that are nuclei, and this function tells FIJI to find "Particles" with the stated parameters and select them.
//The size is in pixels (specified by pixel), and there is a circularity parameter. show is how you want the select to be displayed (do you want them to be numbered?, outlined? etc etc), summarize creates a table with summary statistics (this has been removed in 1.33)
// Display means it will open the result of its analysis (in this case, outlines) in a new window. Add means it will add the shapes it found to the ROI manager. The ROI manager is a region of interest manager, which basically stores objects you marked, and 
// most importantly, can be used to overlay.

if (channel_number != 2){
selectWindow("Colocalizated points (RGB) ");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display");   //Size of Colocalizations to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Foci Colocalization");

// If we have more than 2 channels, we have done colocalization, so we must count what we have found in the colocalization window. To do this, we use the binary command to leave only the regions that have overlap, then we use the analyze particles
// command to find and select them. Here we use different parameters from above. This is because above, true nuclei are large, if it is too small it picks up garbage. Here, large colocalizations are probably garbage, while a colocalization of only 1 pixel is
// likely to be spurious. In general, we should have an advanced settings tab to allow the user to change these parameters if they know WHY they are doing it. Otherwise you need to go into the code. Fill holes is a command to make sure that there are not donuts in the
//spots we found, as this will mess with the proper counting. Next we use the find maxima function on the particles we found. This opens a new window with each particle we found being converted into a single pixel. We do this to take advantage of a trick which I 
// will explain. A single pixel in a binary image has a value of 255. Therefore, if count the total intensity on the image (or in a nucleus which we overlayed, but we haven't gotten there yet), we will get # of pixels x 255. However, if we tried to do this with the
//particles we found we would get a different value, since they all might have a different area. Some might be large, others small. Therefore, we convert each one to a single pixel (the find maxima step). Now when we count we get what is essentially
// number of particles found x 255. Later in the excel sheets, we simple divide the output by 255 to get the number of colocalizations or foci found. The next step is to use the ROI manager to overlay ALL the nuclei from the blue channel (which we found and added).
// We make the ROI Manager select everything twice, because it is finicky and you want it to deselect and then reselect to make sure (and this is the way you do it I think. At least this is guaranteed to work). That is why you have the weird double command. Next you
// want to make sure your results table is clear from any previous data, and finally you tell FIJI to measure everything in the ROIs overlayed on our image (in this case the colocalized points). Now recall that we had told it as the very first command to only 
// measure integratedArea. This means it will take the value of the pixels in the ROI. So 255 x the number of particles it found! renameresults renames the results window to something different, and prevents it from getting overwritten and deleted.

selectWindow("Composite (RGB) (red)");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of 53BP1 Foci to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Red Foci");
}

//Same as above but with the red channel. This is just counting the number of foci in the red channel, not colocalizations.

selectWindow("Composite (RGB) (green)");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of Telomeres to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Green Foci");

//Same as above but with the green channel

if (channel_number == 4 && triple_coloc == 1) {
selectWindow("third_proc");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of Third Foci to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Third Foci");

}

//Same as above but with the third channel if it was a 4 channel image and they told me to do 3 channels.

selectWindow("Green Foci");
			nameG = "First Foci"; 
			index = lastIndexOf(nameG, "."); 
			if (index!=-1) nameG = substring(nameG, 0, index); 
			nameG = nameG + ".csv"; // Change here for put a different name
			saveAs("Measurements", Telosave+list[n]+ " " +nameG); 

// Here we are saving the results tables into csv format. We also have some poorly coded method for numbering the files so that we can tell what is what later. Measurements tells it to save it as data I assume, however I can no longer find such a command.
//It is possible it is the archaic form of "Results". But it works, so I haven't changed it.

if (channel_number != 2){			
selectWindow("Red Foci");
			nameR = "Second Foci"; 
			index = lastIndexOf(nameR, "."); 
			if (index!=-1) nameR = substring(nameR, 0, index); 
			nameR = nameR + ".csv"; // Change here for put a different name
			saveAs("Measurements", BP1save+list[n]+ " " +nameR); 

// Same

selectWindow("Foci Colocalization");
			nameC = "Foci Colocalization Count"; 
			index = lastIndexOf(nameC, "."); 
			if (index!=-1) nameC = substring(nameC, 0, index); 
			nameC = nameC + ".csv"; // Change here for put a different name
			saveAs("Measurements", Colocsave+list[n]+ " " + nameC); 
			filenameIndex++;
}

// Same

if (channel_number == 4 && triple_coloc == 1){
	selectWindow("Third Foci");
			nameT = "Third Foci"; 
			index = lastIndexOf(nameT, "."); 
			if (index!=-1) nameT = substring(nameT, 0, index); 
			nameT = nameT + ".csv"; // Change here for put a different name
			saveAs("Measurements", Thirdsave+list[n]+ " " +nameT); 

// Same

selectWindow("third_proc");
run("Invert LUT");
//Remember where we had the black background stuff? We now need to undo this here for this guy. I am not entirely sure why, but somehow it ended up that way. So I fixed it. 
// Perhaps you can tell that when doing this I was more focused on something that worked than pretty or entirely logical.
run("Cyan");
//This is just to make it another color visually for people to be able to see their images properly.
selectWindow("Composite");
run("Split Channels");
run("Merge Channels...", "c1=C1-Composite c2=C2-Composite c5=third_proc create");
//Here we merge all three channels of the foci we found in the 3-way setting into one image. We save this file later. This is so people can check up on how the program did.
}


selectWindow("Composite");
	nameD = "Foci Colocalization Image";
	saveAs("Tiff", Imagesave+list[n]+ " " +nameD);

//Here we save it. We always save this no matter the channels. Basically it just shows the points we found.

selectWindow("Drawing of Blue");
	nameB = "Nuclei Image";
	saveAs("Tiff", Nucleisave+list[n]+ " " +nameB);
	

//Drawing of blue is the output of the analyze particles. We save this so people can see if it did a good job of finding nuclei.

array1 = newArray("0");; 
for (i=1;i<roiManager("count");i++){ 
        array1 = Array.concat(array1,i); 
        } 
roiManager("select", array1); 
roiManager("Delete");

//This clears all the stuff in the ROI manager. If you just close it and reopen it, it will still have the ROIs.

run("Close All");
if (isOpen("ROI Manager")) {
     selectWindow("ROI Manager");
     run("Close");
}

//Here we close all the open IMAGE!!! windows, then close the ROI manager. The ROI manager is a special window so we need to close it like that. Don't ask why. You can't do it otherwise. You can never select it. Its stupid. I know. This is how it is.

call("java.lang.System.gc");

//Some trash cleaning i think. It is here for the same reason the other trash cleaning is.

closelist = getList("window.titles"); 
     for (x=0; x<closelist.length; x++){ 
     winame = closelist[x]; 
      selectWindow(winame); 
     run("Close");
     }
//Here we close anything else that may be open and wasn't closed by the closeall function.

} 

if (first_autocontrastfull == 1){
print("First Foci Auto-contrasted");
}
else {
print("First Foci Contrast Values" + " " + first_autocontrastmin + " " + first_autocontrastmax);
 }

if (channel_number != 2){		
if (second_autocontrastfull == 1){
print("Second Foci Auto-contrasted");
}
else {
print("Second Foci Contrast Values" + " " + second_autocontrastmin + " " + second_autocontrastmax);
 } }

if (channel_number == 4 && triple_coloc == 1){
if (third_autocontrastfull == 1){
print("Third Foci Auto-contrasted");
}
else {
print("Third Foci Contrast Values" + " " + third_autocontrastmin + " " + third_autocontrastmax);
 }	
}
 
print("First Threshold Value is" + " " + first_thresh);


if (channel_number != 2){		
print("Second Threshold Value is" + " " + second_thresh);
}

if (channel_number == 4 && triple_coloc == 1){
print("Third Threshold Value is" + " " + third_thresh);
}

selectWindow("Log");  //select Log-window 
saveAs("Text", dir2+"Value Log");

if (isOpen("Log")) { 
         selectWindow("Log"); 
         run("Close"); 
     } 

}

//Here we just save all the values that the person used for their analysis to make sure they have a record.

exit










macro "Close All Windows [F4]" 
  { 
    while (nImages>0) 
   { selectImage(nImages); close(); 
   list = getList("window.titles"); 
     for (i=0; i<list.length; i++){ 
     winame = list[i]; 
      selectWindow(winame); 
     run("Close"); 

     } exit



macro "Value Tester [F6]" {
runcycle = 1
for (tryagainprogram=0; tryagainprogram==0; runcycle++) { 


waitForUser("Press OK and then please open a test file");
open();

run("Set Measurements...", "integrated redirect=None decimal=3");
test_image = File.directory;
test_name = File.name;
triple_coloc = false;

print("The test image is");
print(test_image + test_name);
print("Test cycle..." +runcycle);

channel_number = getNumber("How Many Channels?", 3);
dapi_order = getNumber("Which channel is DAPI?", 1);
if (channel_number == 4){
rows = 2;
  columns = 2;
  rc = rows*columns;
  labels = newArray("Channel 1", "Channel 2", "Channel 3", "Channel 4");
  defaults = newArray(rc);
  Dialog.create("Please Select Which Channels To Colocalize");
  Dialog.addCheckboxGroup(rows,columns,labels,defaults);
  Dialog.show();
       channels = newArray();
C_1 = Dialog.getCheckbox();
C_2 = Dialog.getCheckbox();
C_3 = Dialog.getCheckbox();
C_4 = Dialog.getCheckbox();


if (channel_number == 4 && ((C_2 == 1 && C_3 == 1 && C_4 == 1) || (C_1 == 1 && C_3 == 1 && C_4 == 1) || (C_1 == 1 && C_2 == 1 && C_3 == 1))){
	triple_coloc = true;

} else {
	triple_coloc = false;
}}


if (channel_number == 4) {
run("Stack to Hyperstack...", "order=xyczt(default) channels=4 slices=1 frames=1 display=Color");
	if (dapi_order == 1)
	run("Duplicate...", "title=dapi duplicate channels=1");
	else if (dapi_order == 2)
	 run("Duplicate...", "title=dapi duplicate channels=2");
	 else if (dapi_order == 3)
	run("Duplicate...", "title=dapi duplicate channels=3");
	else if (dapi_order == 4) 
		run("Duplicate...", "title=dapi duplicate channels=4");
			
	if (triple_coloc == 1){
			if (C_1 == 1 && C_2 == 1 && C_3 == 1){
				print("Colocalized Channels are 1 and 2 and 3");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=2");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_3 == 1 && C_4 == 1){	
				print("Colocalized Channels are 2 and 3 and 4");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			
			}
			if (C_1 == 1 && C_3 == 1 && C_4 == 1){	
				print("Colocalized Channels are 1 and 3 and 4");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			}

	if (triple_coloc == 0){
			
						
			if (C_1 == 1 && C_2 == 1) {
				print("Colocalized Channels are 1 and 2");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=2");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
				}
			if (C_1 == 1 && C_3 == 1) {
				print("Colocalized Channels are 1 and 3");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_1 == 1 && C_4 == 1) {
				print("Colocalized Channels are 1 and 4");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=1");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_3 == 1) {
				print("Colocalized Channels are 2 and 3");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=3");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_2 == 1 && C_4 == 1) {
				print("Colocalized Channels are 2 and 4");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=2");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			if (C_3 == 1 && C_4 == 1) {
				print("Colocalized Channels are 3 and 4");
				selectWindow(test_name);
				run("Duplicate...", "title=firstfocichannel duplicate channels=3");
				selectWindow(test_name);
				run("Duplicate...", "title=secondfocichannel duplicate channels=4");
				run("Merge Channels...", "c1=[firstfocichannel] c2=[secondfocichannel] c3=[dapi] create");
			}
			}	
close(test_name);
close("firstfocichannel");
close("secondfocichannel");
close("dapi");
selectWindow("Composite");
rename(test_name);
}

if (channel_number == 3 || channel_number == 4){
run("Stack to Hyperstack...", "order=xyczt(default) channels=3 slices=1 frames=1 display=Color");
}

if (channel_number == 3){

if (dapi_order == 1)
	run("Arrange Channels...", "new=231");
	else if (dapi_order == 2)
	 run("Arrange Channels...", "new=132");
	 else if (dapi_order == 3)
	run("Arrange Channels...", "new=123");
}

if (channel_number == 2){
	run("Stack to Hyperstack...", "order=xyczt(default) channels=2 slices=1 frames=1 display=Color");
	if (dapi_order == 1)
	run("Arrange Channels...", "new=21");
	else if (dapi_order == 2)
	 run("Arrange Channels...", "new=12");
}	 

run("32-bit");

if (channel_number != 2){
run("Duplicate...", "title=dapi duplicate channels=3");
selectWindow(test_name);
run("Duplicate...", "title=bp1 duplicate channels=2");
selectWindow(test_name);
run("Duplicate...", "title=telo duplicate channels=1");
run("Duplicate...", "title=telo1");
run("Median...", "radius=10");
imageCalculator("Subtract create", "telo","telo1");
selectWindow("bp1");
run("Duplicate...", "title=bp2");
run("Median...", "radius=10");
imageCalculator("Subtract create", "bp1","bp2");
run("Merge Channels...", "c1=[Result of telo] c2=[Result of bp1] c3=[dapi] create");
close("telo");
close("telo1");
close("bp1");
close("bp2");
close();
run("Stack to Hyperstack...", "order=xyczt(default) channels=3 slices=1 frames=1 display=Color");
}

if (channel_number == 2){
run("Duplicate...", "title=dapi duplicate channels=2");
selectWindow(test_name);
run("Duplicate...", "title=telo duplicate channels=1");
run("Duplicate...", "title=telo1");
run("Median...", "radius=10");
imageCalculator("Subtract create", "telo","telo1");
run("Merge Channels...", "c1=[Result of telo] c2=[dapi] create");
close("telo");
close("telo1");
close(test_name);
selectWindow("Composite");
run("Stack to Hyperstack...", "order=xyczt(default) channels=2 slices=1 frames=1 display=Color");
selectWindow("Composite");
}




run("Duplicate...", "title=Green duplicate channels=1");
run("Grays");
run("Subtract Background...", "rolling=14");
selectWindow("Composite");

if (channel_number != 2){
run("Duplicate...", "title=Red duplicate channels=2");
run("Grays");
run("Subtract Background...", "rolling=14");
selectWindow("Composite");
run("Duplicate...", "title=Blue duplicate channels=3");
}

else {
	run("Duplicate...", "title=Blue duplicate channels=2");
}

run("Grays");
run("Subtract Background...", "rolling=300");
run("Smooth");
run("Gaussian Blur...", "sigma=3");
setAutoThreshold("Huang dark");
//run("Threshold...");
setOption("BlackBackground", false);
run("Convert to Mask");
selectWindow("Composite");
close();




selectWindow("Green");
run("8-bit");
run("Despeckle");

first_autocontrast = getBoolean("Would you like to auto-contrast the first foci?");
if (first_autocontrast == 1) {


//autocontrast
AUTO_THRESHOLD = 5000; 
 getRawStatistics(pixcount); 
 limit = pixcount/10; 
 threshold = pixcount/AUTO_THRESHOLD; 
 nBins = 256; 
 getHistogram(values, histA, nBins); 
 i = -1; 
 found = false; 
 do { 
         counts = histA[++i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i < histA.length-1)) 
 hmin = values[i]; 
 i = histA.length; 
 do { 

         counts = histA[--i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i > 0)) 
 hmax = values[i]; 
 setMinAndMax(hmin, hmax); 
 //print(hmin, hmax); 
run("Apply LUT"); 
print("1st Foci... Auto-contrasted");
}
   
else {
run("Brightness/Contrast...");
waitForUser("Select your values AND DO NOT PRESS APPLY, then press OK");
getMinAndMax(min, max);
print("First Foci Min value is...");
print(min);
print("First Foci Max value is...");
print(max);
setMinAndMax(min, max);
run("Apply LUT"); }

waitForUser("Zoom in on the foci to identify a cutoff value. When you are done, press OK.");
first_thresh = getNumber("What thresholding value would you like to test for the first foci?",-180);
print("1st Foci Thresholding Value is...");
print(first_thresh);
 
run("Auto Local Threshold", "method=Mean radius=500 parameter_1=first_thresh parameter_2=0 white"); //Thresholding for first one
run("Convert to Mask");
run("Make Binary"); 



if (channel_number != 2){

selectWindow("Red");

run("8-bit");
run("Despeckle");

second_autocontrast = getBoolean("Would you like to auto-contrast the second foci?");
if (second_autocontrast == 1) {


//autocontrast
AUTO_THRESHOLD = 5000; 
 getRawStatistics(pixcount); 
 limit = pixcount/10; 
 threshold = pixcount/AUTO_THRESHOLD; 
 nBins = 256; 
 getHistogram(values, histA, nBins); 
 i = -1; 
 found = false; 
 do { 
         counts = histA[++i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i < histA.length-1)) 
 hmin = values[i]; 
 i = histA.length; 
 do { 

         counts = histA[--i]; 
         if (counts > limit) counts = 0; 
         found = counts > threshold; 
 } while ((!found) && (i > 0)) 
 hmax = values[i]; 
 setMinAndMax(hmin, hmax); 
 //print(hmin, hmax); 
run("Apply LUT");
print("2nd Foci... Auto-contrasted"); 
}   
else {
run("Brightness/Contrast...");
waitForUser("Select your values AND DO NOT PRESS APPLY, then press OK");
getMinAndMax(min, max);
print("Second Foci Min value is...");
print(min);
print("Second Foci Max value is...");
print(max);
setMinAndMax(min, max);
run("Apply LUT"); }

waitForUser("Zoom in on the foci to identify a cutoff value. When you are done, press OK.");
second_thresh = getNumber("What thresholding value would you like to test for the second foci?",-180);
print("2nd Foci Thresholding Value is...");
print(second_thresh);
run("Auto Local Threshold", "method=Mean radius=500 parameter_1=second_thresh parameter_2=0 white"); //Thresholding for second
run("Convert to Mask");
run("Make Binary");
}


if (channel_number != 2){
     run("Merge Channels...", "red=Red green=Green blue=*None* gray=*None* create");
selectWindow("Composite");
run("Stack to RGB");
run("Split Channels");
selectWindow("Composite (RGB) (blue)");
close();
}

else {
	run("Merge Channels...", "red=Green green=Green blue=*None* gray=*None* create");
	selectWindow("Composite");
run("Stack to RGB");
run("Split Channels");
selectWindow("Composite (RGB) (blue)");
close();
selectWindow("Composite (RGB) (red)");
close();
}

if (channel_number != 2){
run("Colocalization ", "channel_1=[Composite (RGB) (red)] channel_2=[Composite (RGB) (green)] ratio=30 threshold_channel_1=15 threshold_channel_2=15 display=255  colocalizated");
}
if (channel_number == 4 && triple_coloc == 1){
		
			selectWindow("Colocalizated points (RGB) ");
			run("Make Binary");
			rename("Colocalizated points Part 1");
			open(test_image + test_name);
			
			
					if ((C_2 == 1 && C_3 == 1 && C_4 == 1) | (C_1 == 1 && C_3 == 1 && C_4 == 1)){
					selectWindow(test_name);
					run("Duplicate...", "title=thirdfocichannel duplicate range=4");
					close(test_name);	
					}
					
					if ((C_1 == 1 && C_2 == 1 && C_3 == 1)){
					selectWindow(test_name);
					run("Duplicate...", "title=thirdfocichannel duplicate range=3");
					close(test_name);	
					}
				
			selectWindow("thirdfocichannel");
			run("Duplicate...", "title=third_med");
			run("Median...", "radius=10");
			imageCalculator("Subtract create", "thirdfocichannel","third_med");
			close("thirdfocichannel");
			close("third_med");
			selectWindow("Result of thirdfocichannel");
			rename("third_proc");
			run("32-bit");
			run("Grays");
			run("Subtract Background...", "rolling=14");
			selectWindow("third_proc");		
			run("8-bit");
			run("Despeckle");
			
			third_autocontrast = getBoolean("Would you like to auto-contrast the third foci?");
			if (third_autocontrast == 1) {
			
			
				//autocontrast
				AUTO_THRESHOLD = 5000; 
				 getRawStatistics(pixcount); 
				 limit = pixcount/10; 
				 threshold = pixcount/AUTO_THRESHOLD; 
				 nBins = 256; 
				 getHistogram(values, histA, nBins); 
				 i = -1; 
				 found = false; 
				 do { 
				         counts = histA[++i]; 
				         if (counts > limit) counts = 0; 
				         found = counts > threshold; 
				 } while ((!found) && (i < histA.length-1)) 
				 hmin = values[i]; 
				 i = histA.length; 
				 do { 
				
				         counts = histA[--i]; 
				         if (counts > limit) counts = 0; 
				         found = counts > threshold; 
				 } while ((!found) && (i > 0)) 
				 hmax = values[i]; 
				 setMinAndMax(hmin, hmax); 
				 //print(hmin, hmax); 
				run("Apply LUT"); 
				print("3rd Foci... Auto-contrasted");
				}
			   
				else {
				run("Brightness/Contrast...");
				waitForUser("Select your values AND DO NOT PRESS APPLY, then press OK");
				getMinAndMax(min, max);
				print("Third Foci Min value is...");
				print(min);
				print("Third Foci Max value is...");
				print(max);
				setMinAndMax(min, max);
				run("Apply LUT"); }
			
			waitForUser("Zoom in on the foci to identify a cutoff value. When you are done, press OK.");
			third_thresh = getNumber("What thresholding value would you like to test for the third foci?",-180);
			print("3rd Foci Thresholding Value is...");
			print(third_thresh);
			 
			run("Auto Local Threshold", "method=Mean radius=500 parameter_1=third_thresh parameter_2=0 white"); //Thresholding for third one
			run("Convert to Mask");
			run("Make Binary"); 

			run("Colocalization ", "channel_1=[Colocalizated points Part 1] channel_2=[third_proc] ratio=30 threshold_channel_1=15 threshold_channel_2=15 display=255  colocalizated");



			
			}


			
selectWindow("Blue");
run("Convert to Mask");
run("Make Binary");
run("Adjustable Watershed", "tolerance=4");
run("Analyze Particles...", "size=1000-infinity pixel circularity=0.00-1.00 show=[Bare Outlines] display add");

if (channel_number != 2){
selectWindow("Colocalizated points (RGB) ");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display");   //Size of Colocalizations to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Foci Colocalization");


selectWindow("Composite (RGB) (red)");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of 53BP1 Foci to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Second Foci");
}

selectWindow("Composite (RGB) (green)");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of Telomeres to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("First Foci");

if (channel_number == 4 && triple_coloc == 1) {
selectWindow("third_proc");
run("Make Binary");
run("Analyze Particles...", "size=2-1000 pixel circularity=0.00-1.00 show=[Masks] display"); //Size of Third Foci to Count
run("Fill Holes");
run("Find Maxima...", "noise=10 output=[Single Points] light");
roiManager("Show All with labels");
roiManager("Show All");
run("Clear Results");
roiManager("Measure");
IJ.renameResults("Third Foci");


selectWindow("Colocalizated points (8-bit) ");
close();
selectWindow("Mask of third_proc Maxima");
close();
selectWindow("Mask of third_proc");
close();
selectWindow("Colocalizated points Part 1");
close();
selectWindow("third_proc");
run("Invert LUT");
run("Cyan");
selectWindow("Composite");
run("Split Channels");
run("Merge Channels...", "c1=C1-Composite c2=C2-Composite c5=third_proc create");
}

if (channel_number != 2){
selectWindow("Composite (RGB) (red)");
close();
selectWindow("Composite (RGB) (green)");
close();
selectWindow("Colocalizated points (8-bit) ");
close();
selectWindow("Colocalizated points (RGB) ");
close();
selectWindow("Drawing of Blue");
close();
selectWindow("Mask of Colocalizated points (RGB) ");
close();
selectWindow("Mask of Colocalizated points (RGB)  Maxima");
close();
selectWindow("Mask of Composite (RGB) (red)");
close();
selectWindow("Mask of Composite (RGB) (red) Maxima");
close();
selectWindow("Mask of Composite (RGB) (green)");
close();
selectWindow("Mask of Composite (RGB) (green) Maxima");
close();
}
else {
	selectWindow("Composite (RGB) (green)");
close();
selectWindow("Drawing of Blue");
close();
selectWindow("Mask of Composite (RGB) (green)");
close();
selectWindow("Mask of Composite (RGB) (green) Maxima");
close();
}
if (isOpen("ROI Manager")) {
     selectWindow("ROI Manager");
     run("Close");
  }

open(test_image + test_name);
selectWindow(test_name);
rename("Original");

waitForUser("Review your results, then press OK");     
tryagainuser = getString("Try Again?", "Y");
if (tryagainuser == "N") {
	tryagainprogram = 1;
}
else{
	tryagainprogram = 0;
	selectWindow("Original");
	close();
	selectWindow("Blue");
	close();
	selectWindow("Composite");
	rename("Test" +runcycle);
}

   }





exit



} 
